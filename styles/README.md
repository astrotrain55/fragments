## Общие принципы
При написании CSS используется [методология БЭМ](https://ru.bem.info/methodology/css/) с нотацией, близкой к Aviasales ([слайды](https://speakerdeck.com/fliptheweb/poghovorim-o-vierstkie-arkhitiektura), [презентация](https://www.youtube.com/watch?v=Updm5lqdhN8)). При этом js и шаблоны, в отличие от "классического" БЭМ, располагаются в структуре отдельно и не связаны напрямую с CSS. Это обусловлено архитектурой системы и предметной областью (не компонентные веб-приложения, а сайты).
Внедрение нескольких уровней переопределения не предусмотрено по умолчанию, но допускается при разработке.
Сторонние библиотеки (например, fancybox), подключаются "как есть", без адаптации к нотации.

## Требования

### Общие требования
- для сброса стилей браузера по умолчанию рекомендуется использовать т. н. `reset.css`
- рекомендуется использовать блочную модель `box-sizing: border-box` для всех элементов
- рекомендуется избегать описания тегов напрямую (`h1`, `p`, `ul`, `input` и т. д.), т. к. семантика тега и его стили могут противоречить друг другу; вместо этого рекомендуется использовать классы вида `.h1`, `.p`, `.ul`, `.input` и т. д., т. к. это не будет мешать генерации конструкций вида `<h2 class="page__header h1"></h2>`
- рекомендуется избегать избыточного кода; если функциональность может быть покрыта определенным количеством элементов и стилей, добавление лишних считается ошибкой (кроме тех ситуаций, когда элемент имеет четкое семантическое значение, либо его использование может облегчить разработку в будущем)
- для добавления визуальных эффектов (бэкграунды, тени и т. п.) допускается использование псевдоэлементов `:before` и `:after`

### Адаптив
- для сайтов с полным адаптивом при любой ширине экрана >= 320px не должно быть горизонтальной полосы прокрутки
- для сайтов без адаптива при любой ширине экрана >= 1024px не должно быть горизонтальной полосы прокрутки, брейкпоинты меньше данной ширины не применяются


### Стандартные элементы
Перечисленные ниже элементы следует описывать не по тегам, а по классам (см. выше). Принципиально рекомендуется делать примеси, чтобы описать стиль элемента один раз в одном месте и иметь возможность применять его в разных модулях.

- необходимо описать стили заголовков `h1` .. `h3` (опционально: `h4` .. `h6`); рекомендуется использовать классы `.h1` .. `.h6`
- необходимо описать стили кнопок: `input[type='button']`, `button`; для них необходимо описать состояния `:hover`, `:active` и `:disabled`; рекомендуется использовать класс `.button`
- необходимо описать стили полей ввода форм: `input[type='text']`, `textarea`, `select`; для них необходимо описать состояния `:focus` и `:invalid` (опционально: `:valid`); при стилизации `select` не рекомендуется использовать js, предпочтительно использование css; рекомендуется использовать классы `.input`, `.textarea`, `.select`
- при необходимости нужно стилизовать `input[type='checkbox']` и `input[type='radio']`; не рекомендуется использовать для этого js, предпочтительно использование css; рекомендуется использовать классы `.checkbox`, `.radio`
- необходимо описать стили списков `ul`, `ol`, предусмотреть при этом вложенные списки; рекомендуется использовать классы `.ul`, `.ol` для корневых элементов, дочерние (ul, ol, li) рекомендуется описать каскадом
- необходимо описать стили абзацев `p`; рекомендуется использовать класс `.p`
- необходимо описать стили ссылок `a`; для них необходимо описать состояние `:hover` (опционально: `:visited` и `:link`); рекомендуется использовать класс `.a`
- необходимо описать стили таблиц `table`; рекомендуется использовать класс `.table`
- необходимо описать стиль текстового блока, который будет применяться к контенту, оформленному в визуальном редакторе и на который не распространяются правила стандартизации; внутри этого блока следует описать стили стандартных элементов по тегам, при необходимости применяя каскадирование; также внутри этого блока следует описать корректные стили для элементов `b`, `strong`, `i`, `em`,  `u`, `ins`, `strike`, `del` и т. д.; рекомендуется использовать класс `.text`

**Пример**
```
.text {
    font: 14px/1.2 Arial, sans-serif;
    color: black;

    a {
        color: blue;
        text-decoration: underline;
    }

    a:hover {
        text-decoration: none;
    }

    p {
        margin: 8px 0;
    }

    ul {
        margin: 8px 0;
        list-style: disc outside;
    }

    ul li {
        margin: 4px 0;
    }

    table[border='1'] {
        border-collapse: collapse;
    }
}
```

### Шрифты
- для подключения несистемных шрифтов рекомендуется использовать сервис [Google Fonts](https://fonts.google.com/); при этом в ссылках на шрифты необходимо указывать только те начертания, которые будут применяться
- если есть необходимость хранить шрифты локально, то можно использовать [сервис для скачивания Google Fonts](https://google-webfonts-helper.herokuapp.com/)
- если шрифта на Google Fonts нет, то необходимо сгенерировать шрифты необходимых форматов, поместить их в директорию `css/fonts` (следует использовать поддиректории при большом количестве шрифтов) и добавить файл `css/src/lib/fonts.css` с правилами `@font-face`
- если есть возможность, необходимо поместить в директорию **все** существующие начертания шрифтов; при этом часть из них может не использоваться в `css/src/lib/fonts.css` либо быть закомментирована; это делается для того, чтобы в том случае, если при будущих доработках понадобится какое-то из ранее не применявшихся начертаний шрифта, программисту не нужно было искать его, а он просто мог добавить новое правило `@font-face`
- необходимые форматы шрифтов: `woff`, `woff2` (опционально: `ttf`, `svg` для поддержки старых браузеров, если это необходимо), [таблица поддержки](https://www.w3schools.com/Css/css3_fonts.asp)
- при написании правил `@font-face` для шрифтов одного семейства и разных начертаний необходимо указывать одинаковый `font-family`, но разные `font-weight` и `font-style`

**Плохо**
```
@font-face {
    font-family: 'Franklin Goth';
    src: url('/css/fonts/FranklinGothicBookC.woff2') format('woff2'),
        url('/css/fonts/FranklinGothicBookC.woff') format('woff'),
        url('/css/fonts/FranklinGothicBookC.ttf') format('truetype');
    font-weight: normal;
    font-style: normal;
}
@font-face {
    font-family: 'Franklin Goth Italic';
    src: url('/css/fonts/FranklinGothicBookC-Italic.woff2') format('woff2'),
        url('/css/fonts/FranklinGothicBookC-Italic.woff') format('woff'),
        url('/css/fonts/FranklinGothicBookC-Italic.ttf') format('truetype');
    font-weight: normal;
    font-style: normal;
}
```
**Хорошо**
```
@font-face {
    font-family: 'Franklin Goth';
    src: url('/css/fonts/FranklinGothicBookC.woff2') format('woff2'),
        url('/css/fonts/FranklinGothicBookC.woff') format('woff'),
        url('/css/fonts/FranklinGothicBookC.ttf') format('truetype');
    font-weight: normal;
    font-style: normal;
}
@font-face {
    font-family: 'Franklin Goth';
    src: url('/css/fonts/FranklinGothicBookC-Italic.woff2') format('woff2'),
        url('/css/fonts/FranklinGothicBookC-Italic.woff') format('woff'),
        url('/css/fonts/FranklinGothicBookC-Italic.ttf') format('truetype');
    font-weight: normal;
    font-style: italic;
}
```

## Ключевые пункты
Список правил, составленный на основе типичных ошибок

### Большой модуль - плохой модуль
Необходимо следовать принципу *Single responsibility*. Один модуль должен описывать одну сущность. Если на выходе получается модуль, содержащий большое количество элементов, очень вероятно, что допущена ошибка при разделении на блоки. В таком случае (в большинстве случаев) следует выделить часть функционала в отдельные, более маленькие модули. *При этом следует понимать, что везде есть исключения*.

**Плохо**
```
<div class="header">
    <div class="header__logo"></div>
    <div class="header__menu">
        <div class="header__menu-item">
            <a href="#" class="header__menu-item-link"></a>
            <div class="header__menu-submenu">
                <div class="header__menu-submenu-item">
                    <a href="#" class="header__menu-submenu-link"></a>
                </div>
            </div>
        </div>
    </div>
</div>
```
**Хорошо**
```
<div class="header">
    <div class="header__logo"></div>
    <div class="header__menu menu">
        <div class="menu__item">
            <a href="#" class="menu__link"></a>
            <div class="menu__submenu">
                <div class="menu__subitem">
                    <a href="#" class="menu__sublink"></a>
                </div>
            </div>
        </div>
    </div>
</div>
```

### Микромодуль - тоже плохой модуль
Обратная ситуация не менее плоха. Если модуль содержит всего 1-2 элемента, не имеет самостоятельного семантического значения и может использоваться только в составе другого модуля, с большой вероятностью допущена ошибка при проектировании. В такой ситуации (в большинстве случаев) следует включить этот модуль с состав другого. *При этом следует понимать, что везде есть исключения*.

**Плохо**
```
<div class="header">
    <div class="header__logo logo">
        <img class="logo__img">
    </div>
</div>
```
**Хорошо**
```
<div class="header">
    <div class="header__logo">
        <img class="header__logo-img">
    </div>
</div>
```

### Необходимо давать блокам/элементам семантические названия
Название блока/элемента должно отражать его назначение, а не быть абстрактным.

**Плохо**
```
<div class="block-1">
    <div class="block-1__element-1"></div>
    <div class="block-1__element-2"></div>
</div>
<div class="block-2">
    <div class="block-2__element-1"></div>
</div>
```
**Хорошо**
```
<div class="advantages">
    <div class="advantages__header"></div>
    <div class="advantages__list"></div>
</div>
<div class="persons">
    <div class="persons__slider"></div>
</div>
```

### Элементы не должны применяться вне своих блоков
**Плохо**
```
<div class="block">
    <div class="block__item"></div>
</div>
<div class="another-block">
    <div class="block__item"></div>
</div>
```
**Хорошо**
```
<div class="block">
    <div class="block__item"></div>
</div>
<div class="another-block">
    <div class="another-block__item"></div>
</div>
```
**Либо**
```
<div class="another-block block">
    <div class="block__item"></div>
</div>
```

### Модификаторы блоков/элементов не должны полностью описывать блок/элемент и применяться отдельно от своих блоков/элементов
**Плохо**
```
.block {
    width: 140px;
    height: 260px;
    color: black;
}
.block--blue {
    width: 140px;
    height: 260px;
    color: blue;
}
.block__item {
    width: 70px;
    height: 130px;
    color: black;
}
.block__item--red {
    width: 70px;
    height: 130px;
    color: red;
}

<div class="block--blue">
    <div class="block__item"></div>
</div>
<div class="block">
    <div class="block__item"></div>
    <div class="block__item--red"></div>
</div>
```
**Хорошо**
```
.block {
    width: 140px;
    height: 260px;
    color: black;
}
.block--blue {
    color: blue;
}
.block__item {
    width: 70px;
    height: 130px;
    color: black;
}
.block__item--red {
    color: red;
}

<div class="block block--blue">
    <div class="block__item"></div>
</div>
<div class="block">
    <div class="block__item"></div>
    <div class="block__item block__item--red"></div>
</div>
```

### Блоки не должны иметь внешних отступов либо настроек позиционирования
**Плохо**
```
.child {
    margin-top: 20px;
    color: black;
}
<div class="parent">
    <div class="child"></div>
</div>
```
**Хорошо**
```
.parent__child {
    margin-top: 20px;
}
.child {
    color: black;
}
<div class="parent">
    <div class="child parent__child"></div>
</div>
```

### Следует избегать использования названий тегов
*Кроме тех случаев, когда это действительно необходимо*.

**Плохо**
```
.block a {
    color: black;
}
<div class="block">
    <a href="#"></a>
</div>
```
**Хорошо**
```
.block__link {
    color: black;
}
<div class="block">
    <a href="#" class="block__link"></a>
</div>
```
**Действительно необходимо** (input в форме генерируется движком, затруднительно дописывать классы)
```
.form__field input[type='text'] {
    width: 100%;
}
<div class="form">
    <div class="form__field">
        <input type="text">
    </div>
    <div class="form__field">
        <input type="text">
    </div>
</div>
```
### Следует избегать использования каскада селекторов
*Кроме тех случаев, когда это действительно необходимо*.

**Плохо**
```
.block .block__item {
    color: black;
}
<div class="block">
    <div class="block__item"></div>
</div>
```
**Хорошо**
```
.block__item {
    color: black;
}
<div class="block">
    <div class="block__item"></div>
</div>
```
**Действительно необходимо** (иначе придется навешивать дополнительные модификаторы для каждой ссылки в красном блоке, что может быть затруднительно)
```
.block__item {
    color: black;
}
.block__link {
    color: black;
}
.block__item--red .block__link {
    color: red;
}
<div class="block">
    <div class="block__item block__item--red">
        <a href="#" class="block__link"></a>
        <a href="#" class="block__link"></a>
        <a href="#" class="block__link"></a>
    </div>
</div>
```

### Подробнее
[В документации БЭМ](https://ru.bem.info/methodology/css/).

## Соглашение по именованию
- `.block` - блок; блоки именуются в нотации `kebab-case`
- `.block--blue` - модификатор блока; *правила модификатора только дополняют или переопределяют некоторые правила блока, но никогда не описывают блок целиком; модификатор никогда не применяется отдельно от блока*; простые модификаторы именуются в стандарте `kebab-case`, при этом в составных модификаторах пары ключ-значение отделяются друг от друга одинарным подчеркиванием `_` (например, `block--size_xl`)
- `.block.is-hidden` - стейт блока, обозначает краткосрочное нахождение блока в определенном состоянии; стейты именуются в нотации `kebab-case`, предпочтительно использовать префиксы `is-` и `has-` (возможны и другие) согласно правилам английского языка
- `.block__item` - элемент; *элемент никогда не используется вне блока*; элементы именуются в нотации `kebab-case`, отделяясь от названия модуля двойным подчеркиванием `__`
- `.block__item--blue` - модификатор элемента; *правила модификатора только дополняют или переопределяют некоторые правила элемента, но никогда не описывают элемент целиком; модификатор никогда не применяется отдельно от элемента*;  простые модификаторы именуются в стандарте `kebab-case`, при этом в составных модификаторах пары ключ-значение отделяются друг от друга одинарным подчеркиванием `_` (например, `block__item--size_xl`)
- `.block__item.is-active` - стейт элемента, обозначает краткосрочное нахождение элемента в определенном состоянии; стейты именуются в нотации `kebab-case`, предпочтительно использовать префиксы `is-` и `has-` (возможны и другие) согласно правилам английского языка

## Организация исходного кода
Исходный код располагается в директории `css/src`. *В списке указываются расширения файлов `.css`, но при этом при применении различных процессоров рекомендуется использовать разные расширения (`.pcss`для PostCSS, `.less` для Less, `.scss` для `Sass` и т. д.)*.

- `main.css` - точка входа; здесь подключаются все необходимые файлы и модули; *если в рамках проекта есть несколько приложений, каждое имеет свою точку входа, которая называется соответствующим образом (например, `main.css`, `mobile.css` и т. д.)*
- `settings.css` - файл, содержащий описание переменных с настройками (например, стандартные цвета, брейкпоинты, шрифты и т. д.)
- `common.css` - файл, содержащий описание общих элементов, не относящихся к конкретным блокам (сюда следует выносить одиночные классы-хэлперы, а также стилевые классы `.h1`, `.table` и т. д.; здесь же следует описать стили для html и body)
- `lib` - директория со сторонними библиотеками; здесь же следует разместить `reset.css`, `fonts.css` и т. д.; файлы в этой директории имеют расширение `.css` и не должны содержать в себе инструкция для процессоров; на них не распространяются стандарты именования
- `mixins` - директория, содержащая в себе примеси, необходимые для работы; *нет четкого стандарта именования файлов, содержащих примеси, однако примеси следует группировать по файлам согласно их назначению и называть файлы таким образом, чтобы разработчик смог понять, примеси какого типа в нем содержатся*
- `modules` - директория, содержащая модули, описывающие блоки; каждый файл в этой директории должен содержать описание **строго одного** блока и должен иметь название, соответствующее названию блока (например, блок `.header` со всеми элементами и правилами адаптива должен быть описан в файле `css/src/modules/header.css`); при необходимости допускается организация в этой директории иерархической структуры поддиректорий, в которых будут располагаться файлы модулей, но правило "один файл = один блок" не может быть нарушено

